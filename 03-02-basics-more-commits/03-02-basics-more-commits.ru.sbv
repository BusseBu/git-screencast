0:00:01.270,0:00:06.870
Я снова в редакторе. И теперь добавлю к проекту новый каталог, который я назову с "src".

0:00:07.810,0:00:13.919
Готово. А теперь я попытаюсь добавить этот каталог в git при помощи команды "git add src"

0:00:14.590,0:00:16.590
Вводим "git status"

0:00:17.349,0:00:20.429
Хм, странно. Изменений нет. Ну-ка, давайте: "git commit"

0:00:21.669,0:00:23.320
Ничего не произошло.

0:00:23.320,0:00:27.119
Более того, git пишет: "Нечего коммитить. Рабочее дерево чистое".

0:00:28.150,0:00:29.560
В чем же дело?

0:00:29.560,0:00:31.509
А тут нас ждет небольшой сюрприз.

0:00:31.509,0:00:38.879
Дело в том, что git по историческим причинам не умеет работать c пустыми директориями. Как правило, он такие директории просто не видит.

0:00:39.370,0:00:44.970
Обычно, чтобы это обойти, директорию делают непустой, положив в неё вспомогательный файлик нулевого размера,

0:00:45.360,0:00:51.360
обычно его называют ".gitkeep", чтобы было понятно, зачем он вообще. И тогда уже её можно добавить.

0:00:51.360,0:00:58.420
В нашем случае, впрочем, в этом файле нет необходимости, потому что мы сейчас в директории "src" создадим файл "srcipt.js".

0:00:58.420,0:01:03.840
Ну и напишем здесь какой-нибудь скрипт.
Для git совершенно неважно, какой язык программирования я использую.

0:01:05.160,0:01:08.780
В данном случае это Javascript. 
Готово.

0:01:09.640,0:01:11.640
И подключим этот файл в "index.html"

0:01:12.850,0:01:14.590
Cохраняю изменения.

0:01:14.590,0:01:17.850
Теперь снова откроем терминал и введем "git status".

0:01:18.850,0:01:20.850
Теперь вывод состоит из двух частей.

0:01:21.130,0:01:24.179
Сверху находятся изменения в тех файлах, которые git отслеживает,

0:01:24.540,0:01:29.980
то есть которые есть в индексе. А ниже он показывает, что в проекте появилась неизвестная ему директория.

0:01:30.520,0:01:34.860
Обратите внимание, он показывает только директорию, не файлы внутри нее.

0:01:35.040,0:01:39.220
Предполагается, что если директория неизвестна, то и файлы внутри неё и подавно.

0:01:39.220,0:01:44.400
Давайте добавим наше изменение в git. Для этого используем команду "git add ."

0:01:44.400,0:01:48.340
То есть передадим в "git add" весь текущий каталог

0:01:48.340,0:01:51.720
Если "git add" получает каталог, то добавляет в индекс все изменения,

0:01:51.940,0:01:58.140
которые в нем есть. Это очень удобно, если мы сделали одно, другое, третье  - "git add ." добавляет всё.

0:01:58.140,0:02:03.020
Давайте посмотрим git status. 
Ну вот. Видно что в индекс добавлены оба файла.

0:02:03.780,0:02:08.360
Команда "git add .", которую мы использовали очень удобна, но у нее бывает побочный эффект.

0:02:09.120,0:02:15.000
Дело в том, что в директории проекта могут быть какие-то файлы, которые мы не хотим добавлять в репозиторий.

0:02:15.200,0:02:19.560
К примеру, сейчас я открыл проект в другом редакторе - Webstorm.

0:02:19.560,0:02:23.740
Я даже делать в нем ничего не буду. Просто закрою и вернусь обратно.

0:02:24.260,0:02:31.000
Обратите внимание: в рабочей директории появился новый каталог ".idea". Он содержит служебные файлы Webstorm'a.

0:02:31.440,0:02:36.499
И если мы вызовем "git add .", то наряду с нашими файлами в индекс попадут и они.

0:02:37.100,0:02:42.580
Но служебные файлы редактора явно не должны быть в репозитории. Для того, чтобы отменить добавление,

0:02:42.580,0:02:49.520
воспользуемся командой, которую git сам нам любезно подсказывает вот здесь: "git reset HEAD .idea"

0:02:50.240,0:02:53.500
Сбрасывает изменение в индексе для каталога ".idea".

0:02:53.620,0:02:58.400
Вообще, команда "git reset" очень мощная. Она позволяет откатывать самые разные изменения.

0:02:58.400,0:03:02.760
Более подробно мы разберём её синтаксис в одном из дальнейших выпусках скринкаста.

0:03:03.120,0:03:11.580
Ну а чтобы такой проблемы не возникало в будущем, давайте создадим файл ".gitignore и поместим туда ".idea"

0:03:11.960,0:03:17.940
Теперь, если я запущу "git status", то мы видим изменения, которые проиндексировали ранее.

0:03:18.260,0:03:23.640
И видим новый файл ".gitignore", а вот ".idea" не видим, хотя на самом деле она там есть.

0:03:23.740,0:03:27.420
Просто она в игрор-файле, и большинство команд git её игнорирует.

0:03:28.000,0:03:34.060
При этом стоит иметь ввиду, что даже если что-то в игнор-файле, мы можем заставить git добавить это в индекс,

0:03:34.120,0:03:37.800
указав у "git add" флаг "--force" или коротко "-f".

0:03:37.800,0:03:44.020
Это бывает удобно, например, когда добавляемой файл находится где-то глубоко внутри игнорируемой директории.

0:03:44.020,0:03:49.740
Ну а когда файл окажется в индексе, то все изменения в нем уже будут отслеживаться независимо от ".gitignore"

0:03:49.740,0:03:56.040
Так что в дальнейшем с файлами, которые так добавлены мы работаем как обычно. 
Никакие дополнительные флаги не будут нужны.

0:03:56.600,0:04:02.020
Замечу, что больше информации по игнорированиям, по ".gitignore" вы найдете в соответствующем выпуске скринкаста.

0:04:02.760,0:04:10.099
Сейчас для еще лучшей демонстрации того, что такое индексы, я перешел редактор и внес некоторые дополнительные изменения в index.html,

0:04:10.260,0:04:13.639
а именно вызвав функцию hello, которая объявлена в подключенном скрипте.

0:04:14.250,0:04:18.410
Теперь, если набрать "git status", то можно увидеть очень интересную вещь.

0:04:18.780,0:04:24.380
В индексе, как показано в первой части вывода, находится ровно те изменения, которые мы добавляли ранее.

0:04:24.720,0:04:26.749
То есть, когда мы добавляем файл в индекс,

0:04:26.980,0:04:32.780
то там сохраняется не только имя, а и новое содержимое целиком, и при запуске команд "git commit"

0:04:33.000,0:04:40.700
в репозиторий попадет именно оно: то, что мы добавили в индекс. Ну а изменения, сделанные после этого, есть пока только в рабочей директории.

0:04:41.120,0:04:46.680
Вот в этой секции как раз перечисляются те файлы в которых есть непроиндексированные изменения

0:04:46.680,0:04:51.640
В нашем случае мы только что поправили "index.html", поэтому вот он здесь появился.

0:04:52.020,0:04:58.880
И наконец в третьей части находятся файлы, которые git не отслеживает. ".gitignore" мы еще не добавляли в индекс, поэтому он здесь.

0:04:59.820,0:05:05.260
Чтобы сделать коммит с учетом последних изменений, давайте добавим их в индекс. Вот так.

0:05:05.940,0:05:07.530
Теперь "git status".

0:05:07.530,0:05:09.347
Непроиндексированных изменений нет.

0:05:09.347,0:05:16.160
Ну что же, настало время сохранить все в репозитории. Для этого я использую команду "git commit" с флагом "-m".

0:05:16.160,0:05:22.120
"-m" позволяет указывать сообщение прямо здесь без вызова редактора. Это очень удобно, когда сообщение короткое.

0:05:22.380,0:05:25.040
Например, "Поправили проблему такую-то".

0:05:25.820,0:05:29.140
Или в нашем случае: "Добавили скрипт".

0:05:29.340,0:05:33.060
Запускаю. Готово. Наши изменения окончательно сохранены в репозитории.

0:05:33.060,0:05:41.280
И вот идентификатор нового коммита. По нему мы в будущем сможем получить из git текущее состояние файлов проекта, который только что сохранили.

0:05:41.480,0:05:49.200
Теперь, если я посмотрю git status, то видно, что всё чисто, за исключением ".gitignore". Давайте добавим в репозитории его: "git add  .gitignore"

0:05:50.550,0:05:53.090
Вот он появился в индексе и "git commit -m 'Add gitignore'".

0:05:53.789,0:06:01.339
Готово. У кого то может возникнуть вопрос: "Почему просто не добавили ".gitignore" в предыдущий коммит? Зачем сохранять его отдельно?"

0:06:01.820,0:06:06.300
Ответ на него очень важен, так как он касается правильного использование git.

0:06:06.300,0:06:11.400
Надеюсь, он станет вам очевиден после просмотра следующего выпуска.
