0:00:02.660,0:00:09.300
Предположим, что я работаю над проектом, начал писать новую функцию, и тут ко мне подбегает коллега и говорит:

0:00:09.600,0:00:14.500
«Ты знаешь, у нас тут проблема срочная, на ветке master, пожалуйста, переключись и помоги решить».

0:00:14.780,0:00:16.700
Ну что делать, всякое бывает.

0:00:16.840,0:00:20.060
Набираю: "git checkout master"...

0:00:20.960,0:00:23.220
Ошибка. Что произошло?

0:00:23.480,0:00:30.640
Раньше мы делали все переключения на чистом статусе, а теперь у нас есть незакоммиченные изменения в index.html.

0:00:31.160,0:00:33.900
Ошибка возникла потому, что checkout нас защищает.

0:00:34.120,0:00:40.360
Ведь если он сейчас заменит index.html на версию с master, то наши незакоммиченные изменения пропадут.

0:00:40.940,0:00:45.120
Закоммитить их я пока не имею морального права, потому что коммит подразумевает,

0:00:45.120,0:00:50.600
что мы что-то доделали, внесли пусть и небольшое, но осмысленное и целостное изменение в проект.

0:00:50.920,0:00:53.540
А тут я функцию начал писать, но не закончил,

0:00:53.720,0:00:57.880
и коммитить такой сломанный, нерабочий код в проект ни в коем случае нельзя.

0:00:58.420,0:01:03.820
Что же нам с этими изменениями делать, если понадобилось срочно переключиться на другую ветку прямо сейчас?

0:01:04.140,0:01:08.620
Такая ситуация в жизни встречается довольно часто, и мы должны знать, как из нее выходить.

0:01:09.160,0:01:10.820
Основных альтернатив две.

0:01:11.580,0:01:18.520
Первый вариант - это все-таки заставить checkout произвести переключение, указав флаг --force или, коротко, -f

0:01:19.200,0:01:24.160
При этом checkout без всяких предупреждений просто перезапишет файлы версиями из master.

0:01:24.640,0:01:29.200
Видите, переключение прошло успешно: index.html заменён на версию из master.

0:01:29.720,0:01:34.620
Но теперь, если мы вернемся обратно на fix... Видите, наших изменений нет - они пропали.

0:01:35.140,0:01:39.300
Флаг -f интересен тем, что иногда его используют вообще без аргументов

0:01:39.300,0:01:41.560
для отмены всех незакоммиченных изменений.

0:01:41.840,0:01:48.380
Например, я что-то поделал, поэкспериментировал в рабочей директории, возможно, даже добавил в индекс

0:01:48.620,0:01:52.540
и потом вижу: нет, не пойдет. Но как теперь все это удалить?

0:01:53.080,0:01:55.860
Вызываю: "git checkout -f HEAD"...

0:01:56.300,0:02:00.620
Так как HEAD - это ссылка на текущую ветку, то мы переключаемся туда же, где и были.

0:02:00.960,0:02:02.760
То есть смены ветки не произойдет.

0:02:03.240,0:02:10.860
Но флаг -f говорит checkout, что все файлы необходимо перезаписать версиями из той ветки, на которую переключаемся.

0:02:11.320,0:02:15.840
То есть на те, которые находится в репозитории на момент HEAD. Это нам как раз и нужно.

0:02:16.200,0:02:21.900
Для краткости можно даже HEAD удалить, потому что если ветка не указана, то checkout использует HEAD по умолчанию.

0:02:22.180,0:02:23.760
Готово, файлы восстановлены.

0:02:23.960,0:02:28.480
Cтатус у нас сейчас чистый, потому что изменения в индексе -f тоже сбрасывает.

0:02:29.120,0:02:31.320
Это мы посмотрели, как удалить изменения.

0:02:31.560,0:02:34.640
Теперь давайте посмотрим альтернативный выход из ситуации.

0:02:34.840,0:02:39.240
Если мы хотим сохранить изменения, то нам может помочь команда git stash.

0:02:39.500,0:02:42.000
Эта команда собирает незакоммиченные изменения,

0:02:42.200,0:02:45.840
удаляет их из файлов и в специальном виде архивирует в Git.

0:02:46.480,0:02:49.460
Видите, файл в редакторе вернулся к своему исходному виду.

0:02:49.820,0:02:54.480
Статус у нас чистый, и мы можем переключаться: "git checkout master"...

0:02:55.700,0:02:56.600
И обратно.

0:02:57.920,0:02:59.320
Видите, все работает.

0:02:59.960,0:03:04.320
Затем, когда я захочу вернуть изменения: "git stash pop"...

0:03:05.700,0:03:07.340
Видите, изменения вернулись в файл.

0:03:07.800,0:03:12.860
Таким образом, git stash позволяет сохранять неоконченные изменения и потом легко к ним возвращаться.

0:03:13.240,0:03:20.560
Важно иметь в виду, что технически Git не привязывает сохраненные изменения к какой-то определенной ветке или коммиту.

0:03:20.940,0:03:23.140
Поэтому можно сохранить изменения.

0:03:23.300,0:03:27.840
То есть вызвать git stash на одной ветке, а применить git stash pop на другой.

0:03:28.140,0:03:31.960
При этом, если файл в другой ветке, к которому нужно применить изменения -

0:03:31.960,0:03:33.660
в данном случае, index.html -

0:03:33.740,0:03:37.320
отличается от версии в той ветке, с которой эти изменения были сняты, 

0:03:37.400,0:03:42.480
то у Git может возникнуть сложность с наложением изменений, как говорят, «возникнет конфликт».

0:03:42.860,0:03:46.620
Мы подробно рассмотрим, что это такое и как с этим быть в будущих выпусках.

0:03:46.880,0:03:50.160
Но, как правило, такая ситуация со stash происходит при ошибке. 

0:03:50.420,0:03:56.700
Когда мы сделали stash на одной ветке и применили на другой, хотя на самом деле хотели применить на той, где cделали изначально.

0:03:56.920,0:04:03.240
Так что здесь важно внимательно смотреть, где мы сделали stash и где применяем - чтобы нечаянно не выстрелить себе в ногу.

0:04:03.840,0:04:05.640
У git stash есть еще ряд возможностей. 

0:04:05.760,0:04:09.900
Но чтобы не нарушать поток изложения, мы рассмотрим их в отдельном выпуске скринкаста,

0:04:10.000,0:04:14.460
который посвящен именно git stash, где глубже разберемся, как работает эта команда. 

0:04:14.840,0:04:16.680
А сейчас давайте вернёмся к веткам.

0:04:17.020,0:04:20.680
Возможно, после описания этой ситуации у вас возникло впечатление, 

0:04:20.680,0:04:24.060
что любые незакоммиченные изменения препятствуют переключению.

0:04:24.520,0:04:25.620
Но это не так.

0:04:25.900,0:04:30.980
Checkout ругается, только если изменение находится в файле, который различается между ветками.

0:04:31.260,0:04:33.380
То есть которой ему необходимо заменить.

0:04:33.860,0:04:38.280
Как вот в нашем случае, index.html на fix один, а на master - другой.

0:04:38.520,0:04:41.020
А что если файл в обоих ветках одинаковый?

0:04:41.220,0:04:45.120
Это довольно типично. Как правило, между ветками меняется далеко не все.

0:04:45.380,0:04:51.120
Вот и в нашем случае, файл script.js в ветке fix никак не изменился. Он такой же, как в master.

0:04:51.500,0:04:57.600
Все изменения, которые мы делали в ветке fix, относились к index.html, а со script.js мы ничего не делали. 

0:04:57.940,0:05:05.080
Поэтому, если я сейчас удалю незакоммиченные изменения и сделаю их, но на этот раз не в index.html, а в script.js

0:05:05.440,0:05:07.180
(так что вот наш новый статус)

0:05:07.440,0:05:09.720
и теперь вызову git checkout master...

0:05:10.320,0:05:12.420
Вот, видите - переключение прошло. 

0:05:12.760,0:05:17.060
На этот раз нет ошибки, потому что при переключении checkout смотрит в репозиторий:

0:05:17.060,0:05:23.300
«Ага, файл script.js в обоих ветках одинаковый, значит, при переключении его не нужно заменять».

0:05:23.500,0:05:27.340
И оставляет файл как есть, то есть вообще script.js не трогает.

0:05:27.760,0:05:30.920
Соответственно, незакоммиченные изменения в нем остаются как есть.

0:05:31.820,0:05:37.720
При этом checkout делает заметку - видите, "M", от английского слова modified - то есть, «файл изменен».

0:05:37.920,0:05:44.340
Это просто для информации, чтобы мы знали, что переключение прошло успешно, но в файле остались незакоммиченные изменения.

0:05:44.660,0:05:49.960
Мы можем дополнительно убедиться в том, что переключение прошло успешно, если взглянем на index.html.

0:05:50.260,0:05:52.940
Сейчас он вот такой - то есть, соответствует ветке master.

0:05:53.300,0:05:55.040
Давайте переключимся обратно...

0:05:55.700,0:06:01.080
И опять переключение прошло успешно. index.html поменялся на тот, который был в ветке fix.

0:06:01.460,0:06:04.680
 А в script.js, как и ранее, остались незакоммиченные изменения.

0:06:05.220,0:06:08.720
То есть логика проста: если файл между ветками различается

0:06:08.840,0:06:13.100
или бывает, что в одной ветке файл есть, а в другой он был удален, - тогда ошибка.

0:06:13.420,0:06:15.700
А если одинаковый, то изменения сохраняются.

0:06:16.400,0:06:21.240
Я на этом так подробно останавливаюсь, потому что такое поведение checkout может привести к тому,

0:06:21.300,0:06:25.120
что работа, сделанная для одной ветки, нечаянно попадет в другую.

0:06:25.680,0:06:30.020
К примеру, в нашем случае изменения в script.js мы сделали, находясь на ветке fix.

0:06:30.500,0:06:32.780
Возможно мы даже добавили их в индекс. 

0:06:33.120,0:06:37.140
Но если мы переключимся на ветку мастер и вызовем git commit,

0:06:37.340,0:06:40.360
то в итоге новый коммит с нашими изменениями попадет в нее.

0:06:40.880,0:06:46.360
Если мы этого не хотим, то, увидев такое сообщение checkout, мы можем вернуться на предыдущую ветку,

0:06:46.360,0:06:52.640
что-то доделать или заархивировать изменения, используя git stash, - тут уже конкретные действия зависят от ситуации.

0:06:52.960,0:06:58.320
Главное, смотреть на сообщение при выполнении checkout, чтобы такого нечаянного переноса изменений не пропустить.

0:06:58.720,0:07:03.360
В то же время, бывают ситуации, когда такое поведение checkout, наоборот, очень полезно.

0:07:04.160,0:07:09.380
Для примера давайте перенесёмся на 2 коммита назад - на момент, когда мы еще не создали ветку fix.

0:07:09.660,0:07:15.000
В реальной жизни не всегда очевидно, что для какого-то участка разработки нужна именно новая ветка.

0:07:15.180,0:07:21.860
Возможна ситуация, когда мы начали писать на master, думали, что изменение будет очень простое: сейчас доделаем, заккомитим.

0:07:21.980,0:07:27.780
Одно, другое, третье... И вдруг оказывается, что задача гораздо шире, чем предполагалось изначально.

0:07:28.020,0:07:32.700
Доделать прямо сейчас не получится, и естественно было бы выделить ее в отдельную ветку.

0:07:33.200,0:07:36.180
Хорошие новости заключаются в том, что это очень просто.

0:07:36.380,0:07:43.320
Если я сейчас создам новую ветку на текущем коммите и переключусь на нее, то все незакоммиченные изменения окажутся в ней.

0:07:43.800,0:07:45.720
Иными словами, запускаю... 

0:07:46.120,0:07:50.880
Как вы можете видеть на картинке справа, создана ветка fix, указывающая на текущий коммит,

0:07:50.980,0:07:53.100
и команда чекаут переключила HEAD на неё.

0:07:53.400,0:07:59.040
Так как и master, и fix сейчас указывают на один и тот же коммит, тo различий между этими ветками нет.

0:07:59.500,0:08:03.000
Поэтому при переключении все незакоммиченные изменения сохранены.

0:08:03.640,0:08:07.980
Конечно, я могу вернуться и обратно на master, и снова переключиться на fix.

0:08:08.200,0:08:10.600
Как видите, незакоммиченные изменения остаются.

0:08:10.820,0:08:14.780
Они не препятствуют такому переключению между двумя идентичными ветками.

0:08:15.040,0:08:19.020
Но теперь, если я закоммичу все, что я сделал когда-то, находясь на master,

0:08:19.020,0:08:22.100
сохранится на ветке fix, как мы того и хотели.

0:08:22.860,0:08:28.280
Замечу, что так легко перенести изменение в новую ветку нам удалось лишь потому, что они не закоммичены.

0:08:29.060,0:08:32.220
А что если мы уже сделали несколько коммитов не там по ошибке?

0:08:32.660,0:08:34.000
Что ж, в жизни бывает и такое.

0:08:34.260,0:08:37.940
К счастью, это очень легко исправить, как мы с вами увидим в следующем выпуске.
