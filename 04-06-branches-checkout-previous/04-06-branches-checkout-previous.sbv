0:00:00.480,0:00:03.160
В предыдущих выпусках мы добавляли данные в Git.

0:00:03.340,0:00:08.500
В этом посмотрим, как получить более старые версии выбранных файлов, при этом не трогая остальные.

0:00:08.740,0:00:12.760
Допустим, по ходу разработки мы обнаруживаем, что сделали ошибку в каком-то файле.

0:00:12.960,0:00:16.880
И хотели бы вернуть его версию, которая была, скажем, 2 коммита назад.

0:00:17.220,0:00:23.740
При этом нам не надо переключать ветки, и вообще все, кроме этого файла, нужно оставить как есть - только этот файл достать старый.

0:00:24.440,0:00:29.300
Как ни странно, команда, которая может это сделать, нам уже знакома - это git checkout.

0:00:29.860,0:00:34.780
Например, восстановим файл index.html в состояние на момент этого коммита.

0:00:35.500,0:00:39.520
Для этого вызываем git checkout, передавая, во-первых, коммит.

0:00:39.740,0:00:44.700
Можно ссылкой - на этот коммит указывает мастер - или идентификатором, это неважно.

0:00:45.060,0:00:48.880
И затем путь, который нужно восстановить, - в нашем случае index.html.

0:00:49.600,0:00:53.360
При указании пути команда checkout работает проще, чем обычно.

0:00:53.560,0:00:57.080
Она не переключает ветки, а достает только указанный файл -

0:00:57.140,0:01:01.940
или даже можно несколько файлов и директорий указать - на момент переданного коммита.

0:01:02.680,0:01:06.680
Вот, видите. Во-первых, файл обновился, а также, обратите внимание, -

0:01:06.760,0:01:10.340
восстановленные файлы checkout автоматически добавляет и в index.

0:01:10.960,0:01:17.280
Так что, если я сейчас запущу git commit, то эта более старая версия index.html станет текущей.

0:01:18.020,0:01:21.500
Если мы такого не хотим, мы, конечно, можем убрать его из индекса.

0:01:21.780,0:01:25.040
Это сделает команда git reset index.html.

0:01:25.680,0:01:29.420
И, видите, изменения остались в рабочей директории, но из индекса они удалены.

0:01:29.720,0:01:35.900
У команды reset много возможностей - мы изучим ее позже - но в таком виде она сбрасывает индекс для данного конкретного файла.

0:01:36.720,0:01:38.300
Давайте посмотрим еще пример.

0:01:38.560,0:01:43.040
Допустим, мы изменили файл в рабочей директории, что-то поэкспериментировали,

0:01:43.040,0:01:48.600
но нам эти изменения не нравятся и мы хотели бы их отменить, не трогая при этом остальные файлы.

0:01:49.200,0:01:54.940
Аналогично, запустим git checkout. Нам нужна версия файла из текущего коммита, то есть из HEAD.

0:01:56.000,0:02:00.580
Готово. Файл index.html такой же, как мы последний раз сохраняли в репозитории.

0:02:01.120,0:02:05.060
Замечу, что в данной ситуации - давайте вернем изменения в файле -

0:02:05.100,0:02:11.320
можно было бы написать короче, а именно - git checkout index.html, вообще без указания коммита.

0:02:11.640,0:02:15.380
При этом checkout возвращает в рабочую директорию файл из индекса.

0:02:15.740,0:02:21.220
В данном случаем мы изменения не индексировали, так что версия файла в индексе совпадает с версией в HEAD.

0:02:21.400,0:02:23.240
Поэтому результат будет тот же, что и выше.

0:02:23.520,0:02:25.360
Запускаю - и изменения сброшены.

0:02:25.800,0:02:30.680
Конечно, поведение будет отличаться, если мы предварительно проиндексировали какие-то изменения.

0:02:30.960,0:02:33.340
Тогда в рабочую директорию будут возвращены они.

0:02:34.040,0:02:39.340
Итак, checkout с путем и коммитом возвращает файл из этого коммита в рабочую директорию и индекс.

0:02:39.500,0:02:43.260
А checkout только с путем возвращает его из индекса в рабочую директорию.

0:02:44.860,0:02:49.160
С указанием путей связан еще один нюанс, типичный для многих команд Git.

0:02:49.420,0:02:55.960
Вполне возможна ситуация, что у нас в проекте есть файл или директория с тем же названием, что и коммит или ветка.

0:02:56.240,0:03:00.220
Например, мы имеем полное право иметь в проекте директорию с названием master.

0:03:00.620,0:03:07.760
Но, когда мы вызываем git checkout master, - как checkout поймет, что мы имеем в виду: путь master или все-таки ветку?

0:03:08.200,0:03:14.020
Логика здесь очень проста: checkout сначала пытается найти ссылку или коммит с таким идентификатором.

0:03:14.440,0:03:16.520
А если нет, то предполагает, что это путь.

0:03:16.920,0:03:22.020
Соответственно, так как ветка master существует, то такая команда переключится именно на ветку master.

0:03:22.480,0:03:24.140
А что если мы хотим получить путь?

0:03:24.540,0:03:26.980
Для этого указываем перед путем двойной дефис.

0:03:27.200,0:03:32.600
Такая запись позволяет избежать неопределенности - все, что после двойного дефиса воспринимается как путь.

0:03:32.820,0:03:37.780
А если есть ещё какие-то флаги или аргументы, например, коммит, то они ставятся до него.

0:03:38.600,0:03:41.360
Еще раз подчеркну: обычно двойной дефис не нужен.

0:03:41.360,0:03:47.440
Как вот в ситуации с index.html выше, - и так очевидно, что ветки с названием index.html у нас не существует.

0:03:47.980,0:03:51.700
Двойной дефис нужен только для ситуации, когда возможна неопределенность.

0:03:51.980,0:03:54.520
К счастью, на практике они возникают довольно редко.
