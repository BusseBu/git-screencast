0:00:01.520,0:00:05.220
В прошлом выпуске мы удалили ветку feature и тут же восстановили.

0:00:05.420,0:00:09.720
Мы смогли это сделать, потому что помнили, на каком коммите она раньше была.

0:00:10.120,0:00:14.020
Но в реальной жизни мы обычно не запоминаем идентификаторы коммитов.

0:00:14.380,0:00:17.800
Восстановить удаленную ветку, даже если мы забыли идентификатор,

0:00:17.800,0:00:23.260
а также выбраться из других схожих ситуаций, с которыми мы ещё встретимся в будущем, нам помогут ref-логи.

0:00:23.840,0:00:27.680
Каждый раз, когда мы переключаемся с ветки на ветку, делаем коммиты,

0:00:27.680,0:00:31.240
да и вообще при любой операции, которая ведет к изменению ссылок,

0:00:31.300,0:00:38.220
Git записывает это изменение в специальный файл, который называется reflog - от английского слова "reference log", лог ссылок.

0:00:38.700,0:00:41.340
Такие файлы находятся в директории ".git/logs".

0:00:41.660,0:00:45.860
Например, ref-лог для ссылки HEAD находится в файле ".git/logs/HEAD".

0:00:46.140,0:00:47.460
И вот как он выглядит.

0:00:47.780,0:00:51.440
Очень скоро мы посмотрим специальную команду для их более красивого вывода.

0:00:51.840,0:00:54.040
Это просто чтобы мы понимали, как она устроена.

0:00:54.540,0:00:57.700
При каждом изменении коммита, на который указывает HEAD,

0:00:57.720,0:01:02.240
то есть как при обновлении самой HEAD, так и при передвижении в соответствующей ветке,

0:01:02.240,0:01:04.140
в этот файл добавляется новая строка.

0:01:04.460,0:01:11.280
C идентификаторами коммитов, куда HEAD указывала раньше, куда сейчас, кто, когда и зачем произвел изменения.

0:01:11.880,0:01:15.980
Для красивого вывода ref-логов обычно используется команда git reflog,

0:01:15.980,0:01:20.520
к которой добавляют ссылку - например, вывести ref-лог для master, feature.

0:01:21.080,0:01:26.120
И наконец, чаще всего используется команда без аргументов - она выведет ref-лог для HEAD.

0:01:26.640,0:01:33.300
Ну вот, это, в общем-то, то же самое, что мы уже видели в файле, но выведенное в более красивом виде и в обратном порядке.

0:01:33.680,0:01:36.780
От последних значений сверху - вниз, к более старым.

0:01:37.400,0:01:42.740
Посмотрите, пожалуйста. Видите, в самом низу первая запись - это самый начальный коммит.

0:01:43.080,0:01:46.500
Потом мы сделали еще коммит, при этом HEAD стала указывать на него.

0:01:46.720,0:01:52.620
Хотя, строго говоря, она указывает не напрямую, а через ветку, но для ref-лога это неважно. Еще коммит...

0:01:53.000,0:01:56.440
Затем - напомню историю разработки - мы сделали ветку feature.

0:01:56.860,0:02:02.600
Данный факт никак не отражен в этом логе потому, что создание ветки само по себе HEAD не меняет.

0:02:02.960,0:02:07.120
Но сразу после этого мы перешли на нее, то есть запустили команду git checkout.

0:02:07.400,0:02:09.920
При этом HEAD обновляется - и вот запись об этом.

0:02:10.240,0:02:16.340
Затем мы на ветке feature покоммитили, вернулись на master... И так далее до слияния fix и master.

0:02:16.740,0:02:19.080
Для краткости, чтобы вывод не был очень длинным,

0:02:19.080,0:02:23.360
перед этим выпуском я удалил из ref-лога несколько переключений туда-обратно.

0:02:23.560,0:02:25.760
Но все основные операции были сохранены.

0:02:26.400,0:02:32.900
Как видно, наши последние действия, а именно удаление веток fix, feature, пересоздание feature

0:02:33.000,0:02:38.380
в этом логе отсутствуют, потому что они HEAD никак не меняли. Поэтому они здесь и не отражены.

0:02:38.680,0:02:44.220
Замечу, что дополнительная информация о ссылках, которую вы здесь видите скобках, к ref-логу не относится.

0:02:44.380,0:02:48.460
Это так называемое декорирование: для идентификатора коммита  в вывод

0:02:48.480,0:02:52.400
добавляется информация о ссылках, которые на него прямо сейчас указывают.

0:02:52.820,0:02:56.360
То есть, если я, к примеру, удалю ветку feature, то здесь про feature ничего не будет.

0:02:56.680,0:03:01.660
Потому что эта информация в логе не хранится - она просто выводится по текущим данным для красоты.

0:03:02.140,0:03:03.640
Теперь, зачем ref-лог нужен?

0:03:04.020,0:03:06.960
В этом выпуске мы рассмотрим два способа его использования.

0:03:07.540,0:03:14.220
Во-первых, если мы, к примеру, удалили ветку feature неделю назад и уже не помним какие идентификаторы там были,

0:03:14.260,0:03:19.900
но нам понадобились какие-то коммиты из неё, то обычная команда git log их уже, конечно, не выведет.

0:03:20.160,0:03:22.820
Они стали недостижимы: ветки feature больше нет.

0:03:23.200,0:03:28.140
Но, так как когда-то HEAD стоял на этих коммитах, то по ref-логу мы можем их найти.

0:03:28.580,0:03:34.200
К примеру, мы ищем функцию work, которая разрабатывалась в этой ветке, - и вот последний коммит на эту тему.

0:03:34.840,0:03:38.420
Также можно ориентироваться по последнему чекауту с ветки feature.

0:03:38.420,0:03:41.480
Видите, здесь мы последний раз перешли с feature на master.

0:03:41.920,0:03:49.500
В записи ref-лога слева указывается коммит, на который мы перешли. То есть, в нашем случае это на тот момент вершина master.

0:03:49.880,0:03:54.280
Ну а коммит, на котором мы были до этого - то есть, старая вершина feature - находится ниже.

0:03:54.680,0:03:56.220
Давайте восстановим эту ветку.

0:03:56.500,0:04:01.640
Для обращения к записям из ref-лога можно использовать фигурные скобки - ровно как здесь написано.

0:04:02.020,0:04:05.280
То есть, "HEAD", "@" и порядковый номер записи.

0:04:05.420,0:04:10.400
Такой синтаксис возьмет из ref-лога шестую запись и подставит сюда соответствующий идентификатор.

0:04:11.120,0:04:16.860
Под windows в powershell "@" является специальным символом, поэтому понадобится обернуть это в кавычки.

0:04:17.360,0:04:21.780
Ну а под остальными оболочками сработает и так. Готово, ветка пересоздана.

0:04:22.300,0:04:25.800
Замечу, что у команды git reflog есть ряд дополнительных аргументов.

0:04:26.020,0:04:28.020
Вы можете посмотреть о них в документации.

0:04:28.340,0:04:34.480
Обычный вызов подразумевает "show", то есть, показ ref-лога - и это то, что нужно в 90% случаев.

0:04:35.100,0:04:40.400
Но можно также удалять записи из ref-лога, перезаписывать ref-логи, проверять их наличие и так далее.

0:04:40.680,0:04:50.220
Так вот, обычный вызов git reflog - это то же самое, что git reflog show - является алиасом для команды git log --oneline -g.

0:04:50.220,0:04:57.680
Который как раз и переводит git log в особый режим работы, при котором он выводит коммиты не из ветки, как обычно, а из ref-лога.

0:04:58.060,0:05:00.260
Вот, видите, - вывод совершенно такой же,

0:05:00.320,0:05:05.160
поскольку эта команда в точности и есть то же самое, что простой вызов git reflog, только длиннее.

0:05:05.560,0:05:09.960
Соответственно, многие параметры команды git log применимы и к reflog.

0:05:10.280,0:05:13.300
Более подробно мы рассмотрим их в выпуске, посвященном git log.

0:05:13.580,0:05:19.240
Ну а здесь воспользуемся одним из них, а именно --date, чтобы добавить к ref-логу вывод даты.

0:05:19.580,0:05:25.520
Это сделает поиск по ref-логу более удобным, если мы примерно помним, когда было сделано интересующее нас изменение.

0:05:25.840,0:05:28.780
В качестве формата даты выберем стандартный - iso.

0:05:29.200,0:05:33.560
Более подробно о форматах дат можно также посмотреть в отдельном тематическом выпуске.

0:05:34.180,0:05:40.500
И вот, видно, какая запись в ref-логе когда сделана. Теперь гораздо проще найти изменения, которые были неделю назад.

0:05:40.900,0:05:45.320
Для обращения к записям вместо номера в фигурных скобках я также могу указывать дату.

0:05:45.540,0:05:48.820
Cкажем если удалена feature, то, чтобы ее пересоздать, я могу использовать аналогично предыдущему

0:05:48.940,0:05:55.420
то чтобы ее пересоздать я могу использовать аналогично предыдущему обращение через reflog HEAD@,

0:05:55.440,0:06:01.720
но вместо порядкового номера, как раньше (6), я могу указать дату. В данном случае вот эту.

0:06:02.360,0:06:08.760
Обратим внимание, в дате пробел, поэтому я заключу ее в кавычки, чтобы Git воспринимал ее как единое целое.

0:06:09.320,0:06:10.240
Готово.

0:06:11.080,0:06:17.980
Здесь важно понимать, что такое обращение идёт через ref-лог, то есть в ref-логе ищется запись для HEAD с такой датой.

0:06:18.100,0:06:24.500
А если точно такой даты нет, то с более старой максимально приближенной и берется соответствующий идентификатор коммита.

0:06:25.040,0:06:28.760
Чтобы это работало, недостаточно, чтобы коммит просто был в Git.

0:06:29.120,0:06:34.160
Должна быть еще запись в ref-логе с нужным номером или, в данном случае, с подходящей датой.

0:06:34.480,0:06:36.940
И мы приходим к следующему важному моменту.

0:06:37.220,0:06:39.760
По умолчанию ref-логи растут не бесконечно.

0:06:40.060,0:06:45.560
Обычно запись хранится 90 дней, а если коммит стал недостижимым - тогда только 30.

0:06:45.780,0:06:50.380
Так что с момента, когда мы побывали на коммите, у нас есть как минимум 30 дней,

0:06:50.380,0:06:53.300
в течение которых эта запись точно хранится в ref-логе.

0:06:53.600,0:06:55.820
И сам коммит, соответственно, будет в базе.

0:06:56.300,0:07:00.900
Указанные параметры конфигурации можно и поменять, но обычно их оставляют по умолчанию.

0:07:01.420,0:07:07.720
Итак, только что мы рассмотрели использование ref-лога для восстановления данных, то есть поиска потерянных коммитов.

0:07:08.120,0:07:11.540
Это очень важная область применения не только при удалении веток,

0:07:11.540,0:07:15.900
но и при ряде других потенциально опасных операций, которые мы изучим в будущем.

0:07:16.360,0:07:23.040
Есть и еще один способ обратиться к ref-логу, который на практике используется очень часто, обычно в совокупности с git checkout.

0:07:23.120,0:07:27.000
И выглядит он так. То есть, "@" и отрицательное число.

0:07:27.480,0:07:31.820
Такая запись означает предыдущую ветку, с которой был чекаут на данную.

0:07:31.980,0:07:38.160
То есть такая команда checkout фактически возвращает нас обратно на предыдущую ветку, с которой мы ушли на master.

0:07:38.480,0:07:41.560
Что забавно, в нашей ситуации сейчас это не сработает.

0:07:41.860,0:07:43.020
Видите, ошибка.

0:07:43.280,0:07:47.680
Когда я писал этот скринкаст, я сначала очень удивился, а потом уже понял, в чем дело.

0:07:47.900,0:07:51.120
Наверняка, если вы подумаете, то также легко догадаетесь.

0:07:51.560,0:07:53.920
Но для наглядности проведём небольшое исследование.

0:07:54.100,0:07:58.800
Как эта команда узнает на какой ветке мы были? Да очень просто, никакой чёрной магии.

0:07:59.040,0:08:06.360
Для этого она смотрит ref-лог для HEAD - чекаут же HEAD переключает - и ищет буквально там слово "checkout".

0:08:06.760,0:08:11.920
Для наглядности добавлю флаг --no-decorate, который уберет показ ссылок дополнительных.

0:08:12.220,0:08:16.800
И оно сверху ищет последний чекаут на текущую ветку... Вот он.

0:08:17.300,0:08:21.240
И в этой строке смотрит откуда мы чекаутились... С fix.

0:08:21.700,0:08:27.700
Значит, переключиться надо на неё, но ветка fix-то была удалена, ее нет - поэтому ошибка.

0:08:28.100,0:08:33.760
Если указать другое отрицательное число, то Git отступит на указанное количество чекаутов назад.

0:08:34.080,0:08:37.760
Например, если отступить на третий чекаут, то он сделан с feature.

0:08:39.220,0:08:40.780
И, видите, мы переключились.

0:08:41.720,0:08:44.800
Это, конечно, экзотика, обычно используется -1.

0:08:44.860,0:08:51.200
Теперь она сработала, потому что мы только что сделали другой чекаут, и, в настоящий момент предыдущей веткой перед feature была master.

0:08:51.600,0:08:53.160
И можно еще переключиться...

0:08:53.260,0:08:58.400
Теперь уже предыдущая ветка - feature, и так далее. Такие вызовы будут чередовать master и feature.

0:08:59.160,0:09:05.260
Многие команды Git понимают еще более сокращенный вариант такого синтаксиса: вот так, просто "-".

0:09:05.660,0:09:09.400
Но не все. Для тех, которые не умеют, нужно использовать полную запись.