0:00:00.580,0:00:02.860
Рассмотрим ту же ситуацию, что и раньше

0:00:03.000,0:00:03.960
все то же самое

0:00:04.120,0:00:05.340
было слияние

0:00:05.340,0:00:06.600
мы его отменили

0:00:06.600,0:00:07.360
и теперь

0:00:07.360,0:00:09.800
хотим влить доработанную ветку 'feature' заново

0:00:09.980,0:00:11.980
я нарисовал чуток покомпактнее

0:00:11.980,0:00:14.240
чтобы перебазирование также поместилось

0:00:14.240,0:00:17.440
на этот раз, перед тем как делать повторное слияние

0:00:17.440,0:00:19.320
давайте перебазируем ветку 'feature'

0:00:19.340,0:00:21.200
поверх текущей вершины 'master'.

0:00:21.500,0:00:24.860
Картина после перебазирования будет выглядеть вот так

0:00:24.860,0:00:27.000
И теперь, обратите внимание

0:00:27.000,0:00:28.260
что после этого

0:00:28.260,0:00:31.500
уже никаких проблем с предыдущими commit-ами 'feature' не возникнет.

0:00:32.260,0:00:34.520
Напомню, что старые commit-ы 'feature'

0:00:34.520,0:00:36.760
ранее объединялись с веткой 'master'

0:00:36.760,0:00:39.360
и поэтому повторное слияние их игнорировало.

0:00:39.360,0:00:43.140
Но после перебазирования мы уже работаем с их копиями

0:00:43.140,0:00:44.720
которые, как можно видеть

0:00:44.740,0:00:47.200
совершенно точно, не входят в ветку 'master' .

0:00:47.380,0:00:50.440
Поэтому теперь повторное слияние учтет их все

0:00:50.560,0:00:54.860
никаких отмен отмены, как в прошлом выпуске не потребуется

0:00:54.860,0:00:56.720
Это решение удобно тем

0:00:56.720,0:01:00.400
что перебазирование, часто, итак входит в стандартный поток разработки

0:01:00.620,0:01:01.880
То есть перед слиянием

0:01:01.880,0:01:04.060
мы перебазируем ветку, в любом случае.

0:01:04.060,0:01:05.980
И видите, в ситуации с повторным слиянием

0:01:05.980,0:01:07.980
это немного упрощает нам жизнь.

0:01:08.200,0:01:10.420
Впрочем, на практике есть некоторые нюансы

0:01:10.680,0:01:12.340
давайте я их сейчас покажу.

0:01:12.620,0:01:13.480
Начнем с того

0:01:13.480,0:01:17.260
что команда перебазирования в том виде как я ее сейчас написал

0:01:17.260,0:01:20.060
сработает не так как нам нужно

0:01:20.060,0:01:22.260
Если хотите, вы можете поставить на паузу

0:01:22.400,0:01:24.140
вернуться к выпуску про 'rebase'

0:01:24.160,0:01:26.600
и попытаться понять в чем дело самостоятельно.

0:01:26.600,0:01:29.040
Ну а если вы это уже сделали

0:01:29.040,0:01:31.680
или просто лениво тогда я сейчас расскажу.

0:01:31.920,0:01:32.880
Как мы помним

0:01:33.040,0:01:35.160
у 'rebase' есть несколько видов синтаксиса

0:01:35.620,0:01:36.560
Cамый простой

0:01:36.560,0:01:37.360
вот такой

0:01:37.360,0:01:38.880
означает, что текущую ветку

0:01:38.960,0:01:41.060
нужно перебазировать поверх 'master'

0:01:41.320,0:01:43.140
Если добавить еще одну ветку

0:01:43.240,0:01:45.560
то это означает, что перед перебазированием

0:01:45.560,0:01:47.140
нужно на неё переключиться.

0:01:47.140,0:01:51.260
То есть такой синтаксис означает то же самое что 'checkout' на 'feature'

0:01:51.260,0:01:52.900
и потом 'rebase'.

0:01:52.900,0:01:54.220
Тут все нормально.

0:01:54.480,0:01:58.000
мы действительно хотим перебазировать 'feature' поверх 'master'.

0:01:58.000,0:02:02.920
Однако далее при вызове 'rebase' составит себе список commit-ов для переноса

0:02:03.120,0:02:06.400
и в него войдут все commit-ы 'feature', которых нет в 'master'

0:02:06.400,0:02:09.520
то есть появившиеся в 'feature', с момента расхождения веток

0:02:09.520,0:02:12.620
А где оно было? Это последнее расхождение?

0:02:12.620,0:02:14.200
Вот здесь.

0:02:14.200,0:02:16.400
Какие commit-ы есть в 'feature', но нет в 'master'?

0:02:16.520,0:02:17.860
Да только вот этот.

0:02:18.260,0:02:20.180
Так что получится такая картина.

0:02:20.180,0:02:22.180
Перебазирован будет всего 1 commit.

0:02:22.700,0:02:24.400
Как же перебазировать всю ветку?

0:02:24.460,0:02:25.620
Да очень просто.

0:02:25.620,0:02:29.740
У 'rebase' есть альтернативный синтаксис, с флагом '--onto'

0:02:29.740,0:02:33.560
Который позволяет указать, с какого момента начинать перебазировать.

0:02:33.620,0:02:36.120
Порядок аргументов при этом несколько другой.

0:02:36.120,0:02:38.640
После '--onto' указываем. Куда?

0:02:38.660,0:02:39.700
На 'master'.

0:02:39.700,0:02:42.320
Дальше, с какого момента перемещать commit-ы

0:02:42.320,0:02:44.320
Сразу после первого разделения веток

0:02:44.320,0:02:46.280
то есть после этого

0:02:46.280,0:02:49.360
По-умолчанию, будет перебазирована текущая ветка

0:02:49.620,0:02:51.420
но далее мы можем указать ее явно

0:02:51.420,0:02:54.820
В нашем случае мы хотим перебазировать ветку 'feature'

0:02:54.820,0:02:59.000
То есть, опять же,  'checkout' будет на 'feature' и затем перебазирование.

0:02:59.020,0:03:01.020
Запускаю.

0:03:01.020,0:03:03.820
И, видите, первый commit скопировался нормально

0:03:04.020,0:03:06.400
а при копировании второго - возник конфликт

0:03:06.400,0:03:08.400
Давайте посмотрим на него.

0:03:08.400,0:03:10.700
Если вы смотрели предыдущие выпуски

0:03:10.840,0:03:15.600
то наверняка помните, что этот конфликт уже появлялся при слиянии 'feature' и 'master'

0:03:15.960,0:03:18.060
и в этом слиянии, был разрешен.

0:03:18.060,0:03:22.480
Сейчас перебазирование применяет те же изменения заново поверх 'master'

0:03:22.480,0:03:25.080
и конфликт, соответственно, получаем такой же.

0:03:25.840,0:03:27.220
Конечно, здесь он простой.

0:03:27.220,0:03:29.220
Можно заново разрешить и продолжить.

0:03:29.220,0:03:30.520
Но в реальных проектах

0:03:30.520,0:03:32.280
конфликты могут быть куда больше

0:03:32.280,0:03:35.280
да и самих конфликтов тоже может быть больше

0:03:35.280,0:03:38.540
А разрешать одно и то же, по второму разу никому не хочется

0:03:38.540,0:03:41.340
К счастью, опять же по предыдущим выпускам

0:03:41.340,0:03:43.340
мы помним механизм 'rerere'

0:03:43.340,0:03:45.080
который может нам помочь.

0:03:45.080,0:03:45.760
Напомню.

0:03:45.760,0:03:47.960
Он запоминает разрешение конфликтов

0:03:48.160,0:03:50.020
и автоматически применяет их заново

0:03:50.020,0:03:52.020
при обнаружении, таких же конфликтов

0:03:52.020,0:03:53.960
в таких же файлах

0:03:53.960,0:03:55.760
Если он уже был включен

0:03:55.760,0:03:57.280
то наверное он уже это сделал.

0:03:57.280,0:03:59.280
Но, в нашем случае, это не так.

0:03:59.280,0:04:03.440
Поэтому, давайте отменим перебазирование и включим его.

0:04:03.440,0:04:06.860
Но мало включить, 'rerere' нужно научить конфликтам

0:04:06.860,0:04:10.140
чтобы он знал, какие были и как мы их разрешили.

0:04:10.300,0:04:12.900
Обычно он запоминает их сам, если включен

0:04:12.900,0:04:14.440
Но у нас он был выключен.

0:04:14.440,0:04:17.580
Поэтому используем специальный скрипт - 'rerere train'

0:04:17.580,0:04:19.760
который обычно входит в поставку Git

0:04:19.900,0:04:21.900
но находится не по системному пути.

0:04:22.000,0:04:23.040
У меня он здесь.

0:04:23.040,0:04:25.000
У вас может быть в другом месте.

0:04:25.400,0:04:27.480
И научу его вообще всем конфликтам

0:04:27.480,0:04:29.060
из всех веток.

0:04:29.360,0:04:30.520
Готово.

0:04:30.520,0:04:33.360
Теперь запускаю перебазирование еще раз

0:04:37.040,0:04:38.060
и видите...

0:04:38.060,0:04:39.360
вот, Git говорит

0:04:39.360,0:04:42.300
что использовал предыдущее разрешение конфликта.

0:04:42.300,0:04:43.520
Посмотрим файл.

0:04:43.520,0:04:45.240
Да. Конфликта нет.

0:04:45.240,0:04:49.920
Остается добавить его в 'index' и завершить перебазирование.

0:04:54.920,0:04:55.720
Готово.

0:04:55.720,0:04:59.260
Теперь обновленная ветка 'feature' отходит от вершины 'master'

0:04:59.260,0:05:02.520
Давайте завершу слияние. Флагом '--no-ff'

0:05:02.520,0:05:05.240
укажу что слияние должно быть не перемоткой

0:05:05.240,0:05:06.800
а полноценным commit-ом.

0:05:06.800,0:05:10.520
Это не обязательно, но в будущем, нам будет проще понять что произошло.

0:05:12.580,0:05:13.660
Вот и всё.

0:05:13.660,0:05:17.140
Как и ранее, мы заново объединили 'feature' и 'master'

0:05:17.140,0:05:22.680
но на этот раз, не потребовалось дополнительных финтов ушами типо отмены отмены.

0:05:22.800,0:05:24.720
С одной стороны это хорошо

0:05:24.720,0:05:25.420
С другой

0:05:25.420,0:05:27.620
обратим внимание, что это решение

0:05:27.620,0:05:32.260
применимо, только если мы имеем возможность свободно перебазировать 'feature'.

0:05:32.460,0:05:34.300
То есть, если это наша ветка

0:05:34.300,0:05:36.900
которую мы можем легко переписать - передвинуть

0:05:37.080,0:05:39.960
и не иметь проблем с синхронизацей с коллегами.

0:05:39.960,0:05:41.280
Если же это не так

0:05:41.280,0:05:44.560
то вариант с отменой отмены, как описано в предыдущем выпуске

0:05:44.560,0:05:46.560
остается вполне работающим выбором.

0:05:47.980,0:05:50.900
И наконец, еще один вариант повторного слияния

0:05:51.240,0:05:53.680
тоже через 'rebase', но без передвижения ветки.

0:05:53.680,0:05:59.640
Как мы помним, неудобства при повторном вызове -'git merge feature' возникают из-за этой связи.

0:05:59.640,0:06:02.920
Из-за нее Git считает старые commit-ы частью 'master'

0:06:02.920,0:06:04.920
и не берет их при повторном слиянии.

0:06:05.220,0:06:07.720
Если бы вы могли ее просто взять и удалить.

0:06:07.960,0:06:09.670
Все было бы хорошо.

0:06:09.670,0:06:13.520
К сожалению, Git не дает возможности редактировать  commit-ы

0:06:13.560,0:06:15.040
Так просто это не сделать.

0:06:15.280,0:06:19.800
Но мы можем перебазировать ветку 'feature', оставив ее на том же месте где она сейчас

0:06:20.260,0:06:23.640
То есть, иными словами, создать копию всех commit-ов этой ветки

0:06:23.640,0:06:25.120
Вот так.

0:06:25.120,0:06:27.960
И при этом получится, как раз то что нам нужно.

0:06:27.960,0:06:29.960
Для этого перехожу на 'feature'

0:06:29.960,0:06:31.880
и запускаю 'git rebase'

0:06:31.880,0:06:33.860
перебазируем на то же место, где она сейчас

0:06:33.860,0:06:35.860
то есть на этот commit.

0:06:35.860,0:06:37.860
Как видим ничего не произошло.

0:06:38.200,0:06:42.960
Это потому что Git видит, что текущая ветка, итак растет от этого commit-а.

0:06:42.960,0:06:44.760
Значит и делать ничего не надо.

0:06:44.900,0:06:47.320
Чтобы все-таки заставить Git ее скопировать

0:06:47.320,0:06:51.020
используем достаточно редкий флаг 'rebase' - '--no-ff'.

0:06:51.360,0:06:55.520
Он как раз означает, что даже, если commit-ы, вроде как, растут от того же места

0:06:55.520,0:06:57.520
все-равно надо создать их копии.

0:06:59.240,0:07:00.660
Готово.

0:07:00.660,0:07:02.660
Конфликтов, разумеется, никаких нет

0:07:02.680,0:07:03.440
Их быть не может

0:07:03.440,0:07:07.240
потому что ветка перебазируется на то же место, где она и была.

0:07:07.240,0:07:09.900
И дальше можно сделать обычное слияние с 'master'

0:07:09.900,0:07:12.160
Копии commit-ов уже в эту ветку не входят

0:07:12.460,0:07:14.040
поэтому оно их все учтет.

0:07:15.200,0:07:15.700
Итак

0:07:15.700,0:07:19.380
В этом выпуске мы рассмотрели отмену публичных слияний в Git

0:07:19.600,0:07:22.320
то есть таких, для которых нужно делать именно 'revert'.

0:07:22.480,0:07:24.800
И как потом слияние переделать заново.

0:07:24.800,0:07:28.320
Из предложенных способов, сделать повторное слияние.

0:07:28.360,0:07:31.500
Вы можете выбрать тот, который подходит вашему проекту.

0:07:31.500,0:07:32.800
Вашей конкретной ситуации

0:07:32.800,0:07:35.540
Обычно, если ветку можно перебазировать

0:07:35.540,0:07:36.900
то ее перебазируют.

0:07:36.900,0:07:39.240
А если нет, тогда через отмену отмены.
