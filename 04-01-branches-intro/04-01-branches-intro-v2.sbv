0:00:06.540,0:00:07.120
Всем привет!

0:00:07.720,0:00:12.480
Ветвление - одна из важнейших концепций, без которой немыслимо современное использование git.

0:00:12.480,0:00:19.160
Ветка - это по сути изолированный поток разработки, в котором можно делать коммиты так, что их не видно из других веток.

0:00:19.680,0:00:25.500
В этом выпуске я обрисую их использование в общих чертах, а начиная со следующего мы поработаем с ними на практике.

0:00:26.760,0:00:29.240
Ветки сопровождают нас самого начала проекта.

0:00:29.840,0:00:35.500
Как только мы делаем первый коммит, git создает первую ветвь разработки (она называется master).

0:00:36.180,0:00:42.180
Дальше мы можем, не обращая на это внимания, делать еще коммит и еще, в общем вести разработку проекта.

0:00:42.700,0:00:49.740
А теперь представим на минуту, что к нам в голову пришла идея добавить какую-то совершенно новую функциональность и это требует времени.

0:00:50.000,0:00:52.840
Мы хотели бы работать над новой функциональностью эпизодически.

0:00:53.120,0:00:58.580
И пока она не завершена, не смешивать наш экспериментальный код с основным стабильным кодом проекта.

0:00:59.100,0:01:00.880
Как раз для этого очень удобны ветки.

0:01:01.200,0:01:06.840
Мы можем оставаясь в рамках того же проекта, того же репозитория, создать новую ветвь разработки.

0:01:07.000,0:01:08.840
и назвать её, например, feature

0:01:09.100,0:01:11.000
В git есть понятие "текущей" ветки

0:01:11.260,0:01:13.420
То есть ветки с которой мы работаем в данный момент.

0:01:13.700,0:01:17.580
Соответственно мы делаем feature нашей текущей веткой и комитим уже в ней.

0:01:18.160,0:01:20.340
Один комит, другой комит, и так далее

0:01:20.740,0:01:23.020
git позволяет легко переключаться между ветками

0:01:23.340,0:01:27.140
Так что мы можем в любой момент вернуться к нашей основной ветке master

0:01:27.140,0:01:32.300
Которой соответствует предыдущее состояние проекта, без коммитов, связанных с реализацией новой идеи

0:01:32.460,0:01:33.840
И продолжить разработку в ней

0:01:34.260,0:01:36.980
Потом мы можем что-то её поделать по нашей новой идее

0:01:37.320,0:01:39.060
Переключиться обратно на master

0:01:39.560,0:01:41.840
Если вдруг новая идея какая-то плохая

0:01:42.280,0:01:44.100
То мы сможем легко удалить эту всю ветку

0:01:44.360,0:01:47.700
без какого-либо вреда для основной стабильной разработки проекта

0:01:47.960,0:01:50.640
Но, надеюсь, что гораздо чаще будет другая ситуация

0:01:51.020,0:01:52.340
Что новые изменения - хорошие

0:01:52.720,0:01:56.940
И когда мы их доделаем - то сможем объединить их с нашей стабильной веткой master

0:01:57.460,0:02:00.320
Такой подход к разработке называют "тематические ветки"

0:02:00.960,0:02:03.480
Новую функциональность мы реализуем в отдельных ветках

0:02:04.120,0:02:06.360
И интегрируем в master, когда она готова

0:02:07.000,0:02:11.940
При этом параллельно с веткой feature могут быть и другие тематические ветки связанные с другим функционалом

0:02:12.240,0:02:13.600
Например, another-feature

0:02:14.240,0:02:16.240
Разные ветки могут делать разные люди

0:02:16.460,0:02:19.620
например, feature - делаю я, а another-feature - мой коллега

0:02:19.920,0:02:21.380
И мы друг другу никак не мешаем

0:02:21.380,0:02:23.360
Потому что каждый разрабатывает в своей ветке

0:02:23.660,0:02:27.400
Но при этом, если я захочу посмотреть, что он там сделал хорошего

0:02:27.500,0:02:29.340
Я могу легко переключиться на его ветку

0:02:30.000,0:02:32.000
Посмотреть, может быть даже поправить чего-то

0:02:32.280,0:02:33.340
А потом вернуться назад

0:02:33.940,0:02:37.740
Так что и для командной разработки концепция веток очень и очень удобна

0:02:38.520,0:02:41.060
Конечно, это не единственный способ использования веток

0:02:41.420,0:02:47.040
Еще один распространенный подход - это использование веток для одновременной поддержки различных версий проекта

0:02:48.260,0:02:51.820
Опять же, как и ранее ведем разработку - комит еще коми

0:02:52.260,0:02:53.800
И мы решаем сделать релиз

0:02:54.300,0:02:56.560
В проекте у нас наверняка есть еще много возможностей

0:02:57.060,0:02:58.560
И перед релизом мы должны решить

0:02:58.820,0:03:00.880
что именно мы доделываем и включаем в релиз

0:03:01.160,0:03:03.520
а что будем публиковать уже в последующих версиях

0:03:03.780,0:03:06.180
для нового релиза мы создадим отдельную ветку

0:03:06.400,0:03:08.400
назовем её: версия 1.0

0:03:08.780,0:03:11.580
с этого момента наша разработка распадается на два потока

0:03:12.060,0:03:14.680
в ветке master мы продолжим делать новые фичи

0:03:15.020,0:03:17.540
а в ветке v1.0 мы будем шлифовать те возможности

0:03:17.700,0:03:19.260
которые решено включить в релиз

0:03:19.540,0:03:21.060
но ничего нового писать не будем

0:03:21.840,0:03:24.100
далее я переключаюсь на ветку v1.0

0:03:24.340,0:03:25.720
или передаю ее коллеге

0:03:26.100,0:03:28.320
И он делает в ней комит, ещё комит

0:03:28.840,0:03:30.180
в общем готовит её к релизу.

0:03:31.000,0:03:33.840
при этом, так как git позволяет легко переключаться между ветками.

0:03:34.020,0:03:37.120
параллельно может идти разработка новых возможностей в master

0:03:37.700,0:03:42.400
Конечно, бывают ситуации, когда какая-то ошибка существовала ещё до разделения веток

0:03:42.860,0:03:46.020
И сейчас её нужно исправить и в master и в v1.0

0:03:46.660,0:03:47.520
Что ж, нет проблем

0:03:47.840,0:03:49.520
Исправим эту ошибку в одной из веток

0:03:49.900,0:03:52.160
Как правило, исправления делаются сначала в master

0:03:52.500,0:03:55.680
Например, пусть вот этот содержит исправление ошибки

0:03:55.940,0:03:58.480
А затем git позволяет сделать так называемый cherry picking

0:03:58.920,0:04:00.200
То есть взять любой комит

0:04:00.500,0:04:02.640
и применить его изменения к другой ветке

0:04:02.640,0:04:04.020
В нашем случае к v1.0

0:04:04.340,0:04:06.720
В итоге ошибка будет исправлена и там и там

0:04:07.080,0:04:09.140
И так, далее мы продолжаем разработку

0:04:09.480,0:04:11.200
Добавляем новый функционал в master

0:04:11.460,0:04:13.600
И вот приходит время делать релиз v2.0

0:04:14.240,0:04:16.700
Аналогичным образом делаем для него отдельную ветку

0:04:17.420,0:04:21.260
Там идёт шлифовка тех возможностей, которые решено опубликовать в 2.0

0:04:21.640,0:04:24.280
А в master - то что предназначено для следующих релизов

0:04:24.720,0:04:25.560
И так далее

0:04:26.240,0:04:31.100
И так, ветки позволяют держать в одном репозитории одновременно несколько версий проекта

0:04:31.840,0:04:32.980
переключаться между ними

0:04:33.180,0:04:35.440
и дорабатывать каждую из них независимо

0:04:35.940,0:04:39.360
при этом можно создавать любое количество веток, начиная с любого комита

0:04:39.760,0:04:43.500
например, от ветки v1.0 может исходить ветка v1.1

0:04:44.020,0:04:47.280
такие ветки, которые я сейчас описал, ещё называют "релиз-ветками"

0:04:47.980,0:04:53.420
и это ещё один пример полезного использования веток, в дополнение тематическим, которые я рассмотрел ранее

0:04:54.160,0:04:58.760
важно понимать, что git сам по себе, не требует работы с ветками в том или ином виде

0:04:59.680,0:05:02.080
некоторые проекты используют только тематические ветки

0:05:02.540,0:05:04.120
некоторые - только релизные

0:05:04.540,0:05:05.940
некоторые - их сочетание

0:05:06.380,0:05:10.740
в частности, есть известное сочетание этих двух подходов, которое называется git flow

0:05:10.960,0:05:13.200
всё это вы, конечно, сможете применить

0:05:13.440,0:05:16.680
И для этого мы далее переходим к практическому использованию веток

0:05:17.040,0:05:19.700
и их изучению на примере конкретного git-репозитория
